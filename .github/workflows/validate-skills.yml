name: Validate Skills

on:
  push:
    branches: [main]
    paths:
      - 'skills/**'
  pull_request:
    branches: [main]
    paths:
      - 'skills/**'

jobs:
  validate-structure:
    name: Validate Directory Structure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check skills/<author>/<skill>/ structure
        run: |
          echo "Checking directory structure..."
          errors=0

          # skills/ directory must exist
          if [ ! -d "skills" ]; then
            echo "ERROR: skills/ directory not found"
            exit 1
          fi

          # Each item in skills/ must be an author directory
          for author_dir in skills/*/; do
            author=$(basename "$author_dir")

            # Skip if not a directory
            if [ ! -d "$author_dir" ]; then
              continue
            fi

            echo "Checking author: $author"

            # Each author must have at least one skill
            skill_count=$(find "$author_dir" -mindepth 1 -maxdepth 1 -type d | wc -l)
            if [ "$skill_count" -eq 0 ]; then
              echo "  ERROR: Author '$author' has no skills"
              errors=$((errors + 1))
              continue
            fi

            # Each skill must have SKILL.md
            for skill_dir in "$author_dir"*/; do
              skill=$(basename "$skill_dir")

              if [ ! -d "$skill_dir" ]; then
                continue
              fi

              if [ ! -f "${skill_dir}SKILL.md" ]; then
                echo "  ERROR: $author/$skill is missing SKILL.md"
                errors=$((errors + 1))
              else
                echo "  OK: $author/$skill"
              fi
            done
          done

          if [ $errors -gt 0 ]; then
            echo ""
            echo "Found $errors structure error(s)"
            exit 1
          fi

          echo ""
          echo "All structure checks passed!"

  validate-frontmatter:
    name: Validate SKILL.md Frontmatter
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Validate frontmatter
        run: |
          python3 << 'EOF'
          import os
          import sys
          import yaml
          import re

          REQUIRED_FIELDS = ['name', 'description']
          OPTIONAL_FIELDS = ['author', 'repo', 'license', 'tags']
          NAME_PATTERN = re.compile(r'^[a-z0-9-]+$')

          errors = []
          warnings = []
          skills_checked = 0

          for root, dirs, files in os.walk('skills'):
              if 'SKILL.md' in files:
                  skill_path = os.path.join(root, 'SKILL.md')
                  rel_path = skill_path
                  skills_checked += 1

                  with open(skill_path, 'r') as f:
                      content = f.read()

                  # Extract frontmatter
                  if not content.startswith('---'):
                      errors.append(f"{rel_path}: Missing YAML frontmatter (must start with ---)")
                      continue

                  parts = content.split('---', 2)
                  if len(parts) < 3:
                      errors.append(f"{rel_path}: Invalid frontmatter format (missing closing ---)")
                      continue

                  frontmatter_text = parts[1].strip()

                  try:
                      frontmatter = yaml.safe_load(frontmatter_text)
                  except yaml.YAMLError as e:
                      errors.append(f"{rel_path}: Invalid YAML in frontmatter: {e}")
                      continue

                  if not isinstance(frontmatter, dict):
                      errors.append(f"{rel_path}: Frontmatter must be a YAML mapping")
                      continue

                  # Check required fields
                  for field in REQUIRED_FIELDS:
                      if field not in frontmatter:
                          errors.append(f"{rel_path}: Missing required field '{field}'")
                      elif not frontmatter[field]:
                          errors.append(f"{rel_path}: Field '{field}' is empty")

                  # Validate name format
                  if 'name' in frontmatter and frontmatter['name']:
                      name = frontmatter['name']
                      if len(name) > 64:
                          errors.append(f"{rel_path}: 'name' exceeds 64 characters")
                      if not NAME_PATTERN.match(name):
                          errors.append(f"{rel_path}: 'name' must be lowercase with hyphens only, got '{name}'")

                  # Validate description length
                  if 'description' in frontmatter and frontmatter['description']:
                      desc = frontmatter['description']
                      if len(desc) > 1024:
                          errors.append(f"{rel_path}: 'description' exceeds 1024 characters")

                  # Check for recommended optional fields
                  if 'author' not in frontmatter:
                      warnings.append(f"{rel_path}: Missing recommended field 'author'")
                  if 'repo' not in frontmatter:
                      warnings.append(f"{rel_path}: Missing recommended field 'repo'")

                  # Validate tags format
                  if 'tags' in frontmatter:
                      tags = frontmatter['tags']
                      if not isinstance(tags, list):
                          errors.append(f"{rel_path}: 'tags' must be a list")
                      elif not all(isinstance(t, str) for t in tags):
                          errors.append(f"{rel_path}: All tags must be strings")

                  print(f"Checked: {rel_path}")

          print(f"\nChecked {skills_checked} skill(s)")

          if warnings:
              print(f"\nWarnings ({len(warnings)}):")
              for w in warnings:
                  print(f"  - {w}")

          if errors:
              print(f"\nErrors ({len(errors)}):")
              for e in errors:
                  print(f"  - {e}")
              sys.exit(1)

          print("\nAll frontmatter validation passed!")
          EOF

  test-install:
    name: Test Skill Installation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Test install script simulation
        run: |
          # Simulate installing a skill by copying to a temp directory
          echo "Testing skill installation simulation..."

          INSTALL_DIR=$(mktemp -d)
          echo "Install directory: $INSTALL_DIR"

          # Find first available skill
          SKILL_PATH=$(find skills -name "SKILL.md" -type f | head -1 | xargs dirname)

          if [ -z "$SKILL_PATH" ]; then
            echo "ERROR: No skills found to test"
            exit 1
          fi

          SKILL_NAME=$(basename "$SKILL_PATH")
          echo "Testing with skill: $SKILL_PATH (name: $SKILL_NAME)"

          # Copy skill to install directory
          cp -r "$SKILL_PATH" "$INSTALL_DIR/$SKILL_NAME"

          # Verify installation
          if [ -f "$INSTALL_DIR/$SKILL_NAME/SKILL.md" ]; then
            echo "SUCCESS: Skill installed to $INSTALL_DIR/$SKILL_NAME"
            ls -la "$INSTALL_DIR/$SKILL_NAME/"
          else
            echo "ERROR: SKILL.md not found after installation"
            exit 1
          fi

          # Cleanup
          rm -rf "$INSTALL_DIR"
          echo "Installation test passed!"

      - name: Verify skill can be parsed
        run: |
          python3 << 'EOF'
          import os
          import yaml
          import sys

          # Test that we can parse all skills programmatically
          skills = []
          for root, dirs, files in os.walk('skills'):
              if 'SKILL.md' in files:
                  skill_path = os.path.join(root, 'SKILL.md')
                  parts = root.split(os.sep)

                  # Extract author and skill name from path
                  if len(parts) >= 3:  # skills/author/skill-name
                      author = parts[1]
                      skill_name = parts[2]

                      with open(skill_path, 'r') as f:
                          content = f.read()

                      # Parse frontmatter
                      if content.startswith('---'):
                          fm_parts = content.split('---', 2)
                          if len(fm_parts) >= 3:
                              try:
                                  frontmatter = yaml.safe_load(fm_parts[1])
                                  skills.append({
                                      'path': f"{author}/{skill_name}",
                                      'name': frontmatter.get('name'),
                                      'author': frontmatter.get('author'),
                                      'description': frontmatter.get('description', '')[:50] + '...'
                                  })
                              except yaml.YAMLError as e:
                                  print(f"ERROR parsing {skill_path}: {e}")
                                  sys.exit(1)

          print(f"Successfully parsed {len(skills)} skill(s):\n")
          for s in sorted(skills, key=lambda x: x['path']):
              print(f"  {s['path']}: {s['name']} (by {s['author']})")

          if len(skills) == 0:
              print("ERROR: No skills found")
              sys.exit(1)

          print("\nAll skills are parseable!")
          EOF
